def emit_pkgdata(d):
    from glob import glob
    import json
    import subprocess
    import hashlib

    def process_postinst_on_target(pkg, mlprefix):
        pkgval = d.getVar('PKG_%s' % pkg)
        if pkgval is None:
            pkgval = pkg

        defer_fragment = """
if [ -n "$D" ]; then
    $INTERCEPT_DIR/postinst_intercept delay_to_first_boot %s mlprefix=%s
    exit 0
fi
""" % (pkgval, mlprefix)

        postinst = d.getVar('pkg_postinst_%s' % pkg)
        postinst_ontarget = d.getVar('pkg_postinst_ontarget_%s' % pkg)

        if postinst_ontarget:
            bb.debug(1, 'adding deferred pkg_postinst_ontarget() to pkg_postinst() for %s' % pkg)
            if not postinst:
                postinst = '#!/bin/sh\n'
            postinst += defer_fragment
            postinst += postinst_ontarget
            d.setVar('pkg_postinst_%s' % pkg, postinst)

    def add_set_e_to_scriptlets(pkg):
        for scriptlet_name in ('pkg_preinst', 'pkg_postinst', 'pkg_prerm', 'pkg_postrm'):
            scriptlet = d.getVar('%s_%s' % (scriptlet_name, pkg))
            if scriptlet:
                scriptlet_split = scriptlet.split('\n')
                if scriptlet_split[0].startswith("#!"):
                    scriptlet = scriptlet_split[0] + "\nset -e\n" + "\n".join(scriptlet_split[1:])
                else:
                    scriptlet = "set -e\n" + "\n".join(scriptlet_split[0:])
            d.setVar('%s_%s' % (scriptlet_name, pkg), scriptlet)

    def write_if_exists(f, pkg, var):
        def encode(str):
            import codecs
            c = codecs.getencoder("unicode_escape")
            return c(str)[0].decode("latin1")

        val = d.getVar('%s_%s' % (var, pkg))
        if val:
            f.write('%s_%s: %s\n' % (var, pkg, encode(val)))
            return val
        val = d.getVar('%s' % (var))
        if val:
            f.write('%s: %s\n' % (var, encode(val)))
        return val

    def write_extra_pkgs(variants, pn, packages, pkgdatadir):
        for variant in variants:
            with open("%s/%s-%s" % (pkgdatadir, variant, pn), 'w') as fd:
                fd.write("PACKAGES: %s\n" % ' '.join(
                            map(lambda pkg: '%s-%s' % (variant, pkg), packages.split())))

    def write_extra_runtime_pkgs(variants, packages, pkgdatadir):
        for variant in variants:
            for pkg in packages.split():
                ml_pkg = "%s-%s" % (variant, pkg)
                subdata_file = "%s/runtime/%s" % (pkgdatadir, ml_pkg)
                with open(subdata_file, 'w') as fd:
                    fd.write("PKG_%s: %s" % (ml_pkg, pkg))

    def sha256(fname):
        hash_sha256 = hashlib.sha256()
        with open(fname, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        return hash_sha256.hexdigest()

    packages = d.getVar('PACKAGES')
    pkgdest = d.getVar('PKGDEST')
    pkgdatadir = d.getVar('PKGDESTWORK')

    data_file = pkgdatadir + d.expand("/${PN}")
    with open(data_file, 'w') as fd:
        fd.write("PACKAGES: %s\n" % packages)

    pn = d.getVar('PN')
    global_variants = (d.getVar('MULTILIB_GLOBAL_VARIANTS') or "").split()
    variants = (d.getVar('MULTILIB_VARIANTS') or "").split()

    if bb.data.inherits_class('kernel', d) or bb.data.inherits_class('module-base', d):
        write_extra_pkgs(variants, pn, packages, pkgdatadir)

    if bb.data.inherits_class('allarch', d) and not variants \
        and not bb.data.inherits_class('packagegroup', d):
        write_extra_pkgs(global_variants, pn, packages, pkgdatadir)

    workdir = d.getVar('WORKDIR')

    filemap = {}

    for pkg in packages.split():
        pkgval = d.getVar('PKG_%s' % pkg)
        if pkgval is None:
            pkgval = pkg
            d.setVar('PKG_%s' % pkg, pkg)

        pkgdestpkg = os.path.join(pkgdest, pkg)
        files = {}
        total_size = 0
        seen = set()
        for f in pkgfiles[pkg]:
            relpth = os.path.relpath(f, pkgdestpkg)
            if not pkg in filemap:
                filemap[pkg] = []
            filemap[pkg].append(os.sep + relpth)
            fstat = os.lstat(f)
            files[os.sep + relpth] = fstat.st_size
            if fstat.st_ino not in seen:
                seen.add(fstat.st_ino)
                total_size += fstat.st_size
        d.setVar('FILES_INFO', json.dumps(files, sort_keys=True))

        process_postinst_on_target(pkg, d.getVar("MLPREFIX"))
        add_set_e_to_scriptlets(pkg)

        subdata_file = pkgdatadir + "/runtime/%s" % pkg
        with open(subdata_file, 'w') as sf:
            for var in (d.getVar('PKGDATA_VARS') or "").split():
                val = write_if_exists(sf, pkg, var)

            write_if_exists(sf, pkg, 'FILERPROVIDESFLIST')
            for dfile in (d.getVar('FILERPROVIDESFLIST_' + pkg) or "").split():
                write_if_exists(sf, pkg, 'FILERPROVIDES_' + dfile)

            write_if_exists(sf, pkg, 'FILERDEPENDSFLIST')
            for dfile in (d.getVar('FILERDEPENDSFLIST_' + pkg) or "").split():
                write_if_exists(sf, pkg, 'FILERDEPENDS_' + dfile)

            sf.write('%s_%s: %d\n' % ('PKGSIZE', pkg, total_size))

        # Symlinks needed for rprovides lookup
        rprov = d.getVar('RPROVIDES_%s' % pkg) or d.getVar('RPROVIDES')
        if rprov:
            for p in bb.utils.explode_deps(rprov):
                subdata_sym = pkgdatadir + "/runtime-rprovides/%s/%s" % (p, pkg)
                bb.utils.mkdirhier(os.path.dirname(subdata_sym))
                oe.path.symlink("../../runtime/%s" % pkg, subdata_sym, True)

        allow_empty = d.getVar('ALLOW_EMPTY_%s' % pkg)
        if not allow_empty:
            allow_empty = d.getVar('ALLOW_EMPTY')
        root = "%s/%s" % (pkgdest, pkg)
        os.chdir(root)
        g = glob('*')
        if g or allow_empty == "1":
            # Symlinks needed for reverse lookups (from the final package name)
            subdata_sym = pkgdatadir + "/runtime-reverse/%s" % pkgval
            oe.path.symlink("../runtime/%s" % pkg, subdata_sym, True)

            packagedfile = pkgdatadir + '/runtime/%s.packaged' % pkg
            open(packagedfile, 'w').close()

    if bb.data.inherits_class('kernel', d) or bb.data.inherits_class('module-base', d):
        write_extra_runtime_pkgs(variants, packages, pkgdatadir)

    if bb.data.inherits_class('allarch', d) and not variants \
        and not bb.data.inherits_class('packagegroup', d):
        write_extra_runtime_pkgs(global_variants, packages, pkgdatadir)

    sourceresult = d.getVar('TEMPDBGSRCMAPPING', False)
    sources = {}
    if sourceresult:
        for r in sourceresult:
            sources[r[0]] = []
            for source in r[1]:
                sourcedirents = [d.getVar('PKGD'), d.getVar('STAGING_DIR_TARGET')]
                for dirent in sourcedirents:
                    try:
                        sources[r[0]].append({source: sha256(dirent + source)})
                        break
                    except:
                        pass
                else:
                    sources[r[0]].append({source: None})
        with open(data_file + ".srclist", 'w') as f:
            f.write(json.dumps(sources, sort_keys=True))

        filelics = {}
        for dirent in [d.getVar('PKGD'), d.getVar('STAGING_DIR_TARGET')]:
            p = subprocess.Popen(["grep", 'SPDX-License-Identifier:', '-R', '-I'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=dirent)
            out, err = p.communicate()
            if p.returncode == 0:
                for l in out.decode("utf-8").split("\n"):
                    l = l.strip()
                    if not l:
                        continue
                    l = l.split(":")
                    if len(l) < 3:
                        bb.warn(str(l))
                        continue
                    fn = "/" + l[0]
                    lic = l[2].strip()
                    if lic.endswith("*/"):
                        lic = lic[:-2]
                    lic = lic.strip()
                    filelics[fn] = lic
        with open(data_file + ".filelics", 'w') as f:
            f.write(json.dumps(filelics, sort_keys=True))

        computedlics = {}
        computedpkglics = {}
        for r in sourceresult:
            for subf in r[1]:
                if subf in filelics:
                    if r[0] not in computedlics:
                        computedlics[r[0]] = set()
                    computedlics[r[0]].add(filelics[subf])
        #if computedlics:
        #    bb.warn(str(computedlics))
        dvar = d.getVar('PKGD')
        for f in computedlics:
            shortf = f.replace(dvar, "")
            found = False
            for pkg in filemap:
                if shortf in filemap[pkg]:
                    found = True
                    if pkg not in computedpkglics:
                        computedpkglics[pkg] = set()
                    computedpkglics[pkg].update(computedlics[f])
            if not found:
                bb.warn("%s not in %s" % (f, str(filemap)))
        #if computedpkglics:
        #    bb.warn(str(computedpkglics))
        for pkg in computedpkglics:
            lic = d.getVar('LICENSE_%s' % (pkg))
            if not lic:
                lic = d.getVar('LICENSE')
            bb.warn("License for package %s is %s vs %s" % (pkg, computedpkglics[pkg], lic))

emit_pkgdata(d)

